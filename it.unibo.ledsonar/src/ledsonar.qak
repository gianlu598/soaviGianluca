/*
 * ----------------------------------------------------------------------
 * RUNS ON Raspberry
 *
 * - loads the kb about the system (sonar2021Kb.pl) and showSystemConfiguration
 * - loads the sonar2021ConfigKb.pl and reads the sonar-data source (real or simulated).
 *   	If real, activates the CodedQActor sonardatasource of class sonarHCSR04Support2021
 *   	If simulated, activates the CodedQActor sonarsimulator of class sonarsimulator
 * - setup the sonar-data pipe that emits-on-stream the event sonar:distance( V )
 * - handles the event sonar and emits the event sonarrobot:sonar( D )
 * 
 * TO INTERACT from Rasp to PC without MQTT => 
 *            remove Windows firewall or allow port 8028
 * ----------------------------------------------------------------------
 */

 	//"tcp://mqtt.eclipse.org:1883"
	//mqtt.eclipse.org
	//tcp://test.mosquitto.org
	//mqtt.fluux.io
	//"tcp://broker.hivemq.com" 

System -msglog  ledsonar   
//mqttBroker "broker.hivemq.com" :  1883 eventTopic "sonar/data"

Dispatch sonarstart      : sonarstart(V)  
Dispatch simulatorstart  : simulator(V)
Event 	 tooClose  		 : turnOn( V )     //turn on the led    
Event 	 distanceOk 	 : turnOff( V )      //turn off the led
Event    sonar           : distance( V )   //emitted by rx.sonarSimulator or sensors.sonarHCSR04SupportActor	
Event    sonarrobot      : sonar( V )      //for the application level
 
Context ctxledsonar   ip [host="localhost"     port=8068   ] 
//Context ctxledalone      ip [host="127.0.0.1" 	  port=8069	  ] 	
//REMOVE THE COMMENTS IN CASE OF RESOURCE-AWARE CONFIGURATION 	
Context ctxsonarresource ip [host= "192.168.178.64"    port=8028   ]	//127.0.0.1 Deploy on Rasp
ExternalQActor sonarresource context ctxsonarresource
//ExternalQActor led context ctxledalone
  
//DATA SOURCES
CodedQActor sonarsimulator  context ctxledsonar className "sonarSimulator"  
CodedQActor sonardatasource context ctxledsonar className "sonarHCSR04Support2021"

//Filters
//CodedQActor datalogger     context ctxsonaronrasp className "dataLogger"
CodedQActor datacleaner    context ctxledsonar className "dataCleaner"
CodedQActor distancefilter context ctxledsonar className "distanceFilter"
 
QActor sonar context ctxledsonar {     
[# var simulate = true
   lateinit var firstActorInPipe : ActorBasic 
#]
 	State s0 initial {  		 
 		println("sonar START")
 		discardMsg On		 		
 		/*
 		 * INTROSPECTION
 		 
 		solve( consult("sysRules.pl")	 )
 		solve( consult("sonaronrasp.pl") )
 		solve( showSystemConfiguration   )
 		/*
 		 * CONFIGURATION
 		 */
 		solve( consult("sonar2021ConfigKb.pl")	 )
 		solve( simulate(X) )
		println( currentSolution )	//yes X / on oppure X / off
		[# val x = getCurSol("X").toString() 
		   simulate = ( x == "on")	
		   println( "simulate=$simulate" )
		#] 		
		
		//CREATE THE PIPE
		[#  if( simulate ) firstActorInPipe = sysUtil.getActor("sonarsimulator")!!  //generates simulated data
			else firstActorInPipe           = sysUtil.getActor("sonardatasource")!!  //generates REAL data
 			firstActorInPipe.
				subscribeLocalActor("datacleaner"). 		//removes 'wrong' data''
				//subscribeLocalActor("datalogger").		    //logs (shows) the data generated by the sonar
  				subscribeLocalActor("sonar").				//handles sonarrobot but does not propagate ...
 				subscribeLocalActor("distancefilter").		//propagates led event
 				subscribeLocalActor("led")					//led
  				//subscribeLocalActor("sonar")  
		#]    
  
 		//ACTIVATE THE DATA SOURCE (REAL or SIMULATED)
		if [# simulate #]{forward sonarsimulator -m simulatorstart : simulatorstart(ok) }
 		else{ forward sonardatasource -m sonarstart : sonarstart(ok) }  //payload don't care

  	}  
  	Transition t0  whenEvent sonar -> handleSonarData  
			 		  
 	
  	State handleSonarData{
  		printCurrentMessage
  		 onMsg( sonar : distance(D) ){
  		 	[# val D = payloadArg(0) 
  		 	   //val ev = MsgUtil.buildEvent(name,"sonarrobot","sonar($D)")
  		 	   //emit( ev, false  )  //Not emit for me (but not applies to MQTT)
  		 	   //val distanceInt: Int = D.toInt()
  		 	#]  
  		 	emit sonarrobot : sonar($D)
  		 }
  	}
   	Transition t0 whenEvent sonar -> handleSonarData
 }

QActor led context ctxledsonar {     
[#   
   var state   = false  
#]    
	State s0 initial {  		
  		println("led started")
//  		[# machineExec( "sudo bash led25GpioTurnOn.sh" )#]
  		delay 1000
//  		[# machineExec( "sudo bash led25GpioTurnOff.sh" )#]
 	} 
 	Goto waitCmd       
	 
	State waitCmd{  
		println("led waits ...") 
	}   
	Transition t0     
 		whenEvent tooClose   -> turnLedOn
		whenEvent distanceOk -> turnLedOff
   	  
	State  turnLedOn{  
		printCurrentMessage   
		if [# state #] { println("LED already On! ") }
		else { [# machineExec( "sudo bash led25GpioTurnOn.sh" ) 
				 state = true 	
				#] }
		//machineExec '"sudo bash led25GpioTurnOn.sh"'
// 		[# machineExec( "sudo bash led25GpioTurnOn.sh" ) #]
		updateResource [# "ledstate($state)" #]
		
 	}	  
	Goto waitCmd  
	      
	State  turnLedOff{  
 		printCurrentMessage   
 		if [# state #] { [# machineExec( "sudo bash led25GpioTurnOff.sh" ) 
				 			state = false 	
						  #] }
		else { println("LED already Off! ") }
//		[# machineExec( "sudo bash led25GpioTurnOff.sh" ) #]
		updateResource [# "ledstate($state)"	#]
 	}	
	Goto waitCmd         
}
